{"ast":null,"code":"import React,{useState,useEffect,useCallback}from'react';import Web3 from'web3';import JackpotGameABI from'./abi/JackpotGame.json';import Token100xABI from'./abi/Token100x.json';import BondingCurveABI from'./abi/BondingCurve.json';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const App=()=>{// State variables\nconst[nextJackpotValue,setNextJackpotValue]=useState('0');const[guessCost,setGuessCost]=useState('0');const[web3,setWeb3]=useState(null);const[accounts,setAccounts]=useState([]);const[jackpotContract,setJackpotContract]=useState(null);const[tokenContract,setTokenContract]=useState(null);const[bondingCurveContract,setBondingCurveContract]=useState(null);const[currentGuess,setCurrentGuess]=useState('');const[guessChance,setGuessChance]=useState('0');const[jackpotValue,setJackpotValue]=useState('0');const[hintValue,setHintValue]=useState('');const[liquidityValue,setLiquidityValue]=useState('0');const[tokenPrice,setTokenPrice]=useState('0');const[numTokens,setNumTokens]=useState('1');const[totalSupply,setTotalSupply]=useState('0');const[buySellMode,setBuySellMode]=useState('buy');const[hintCost,setHintCost]=useState('0');const[tokenBalance,setTokenBalance]=useState('0');const[uniquePlayers,setUniquePlayers]=useState(0);const[totalWinners,setTotalWinners]=useState(0);const[isLoading,setIsLoading]=useState(false);const[statusMessage,setStatusMessage]=useState('');const[purchasedHints,setPurchasedHints]=useState([]);const JACKPOT_ADDRESS=process.env.REACT_APP_JACKPOT_ADDRESS||'0x1bCb1B4474b636874E1C35B0CC32ADb408bb43e0';const TOKEN_ADDRESS=process.env.REACT_APP_TOKEN_ADDRESS||'0x0755fb9917419a08c90a0Fd245F119202844ec3D';const BONDING_CURVE_ADDRESS=process.env.REACT_APP_BONDING_CURVE_ADDRESS||'0x2ECA93adD34C533008b947B2Ed02e4974122D525';// Format address for display\nconst formatAddress=address=>{if(!address||address==='0x0000000000000000000000000000000000000000')return'None';return`${address.substring(0,6)}...${address.substring(address.length-4)}`;};// Format large numbers properly\nconst formatTokenAmount=amount=>{if(!amount||amount==='0')return'0';try{// Convert from base units to tokens (6 decimals)\nconst amountStr=amount.toString();// Ensure we have a string\nconst amountBN=new Web3.utils.BN(amountStr);const tokenAmount=amountBN.div(new Web3.utils.BN(10**6));const parsedAmount=parseFloat(tokenAmount.toString());// Format for very large numbers\nif(parsedAmount>=1000000000){const billionsAmount=parsedAmount/1000000000;return`${billionsAmount.toLocaleString(undefined,{maximumFractionDigits:0})}B`;}else if(parsedAmount>=1000000){const millionsAmount=parsedAmount/1000000;return`${millionsAmount.toLocaleString(undefined,{maximumFractionDigits:0})}M`;}else if(parsedAmount>=1000){const thousandsAmount=parsedAmount/1000;return`${thousandsAmount.toLocaleString(undefined,{maximumFractionDigits:0})}k`;}else{return parsedAmount.toLocaleString(undefined,{maximumFractionDigits:6});}}catch(error){console.error('Error formatting token amount:',error,'Input:',amount);return'0';}};// Add this function to fetch hint content from the API\nconst getHintContent=useCallback(async(hintIndex,userAddress)=>{try{const response=await fetch(`/.netlify/functions/getHint?hintIndex=${hintIndex}&userAddress=${userAddress}`);if(response.ok){const data=await response.json();return data.hintContent;}else{const error=await response.json();console.error(\"Error fetching hint:\",error);return\"Error retrieving hint\";}}catch(error){console.error(\"Error connecting to hint API:\",error);return\"Unable to connect to hint server\";}},[]);// Empty dependency array since it doesn't depend on external variables\n// Updated loadPurchasedHints function\nconst loadPurchasedHints=useCallback(async()=>{if(!jackpotContract||!accounts[0])return;try{const hintTotal=parseInt(await jackpotContract.methods.hintCount().call());let purchased=[];// Concurrent hint access checks\nconst hintAccessPromises=Array.from({length:hintTotal},async(_,i)=>{const hasAccess=await jackpotContract.methods.hasAccessToHint(accounts[0],i).call();return hasAccess?i:null;});const hintAccess=await Promise.all(hintAccessPromises);purchased=hintAccess.filter(index=>index!==null);setPurchasedHints(purchased);// Set most recent hint if available\nif(purchased.length>0){const latestHintIndex=purchased[purchased.length-1];const hint=await getHintContent(latestHintIndex,accounts[0]);setHintValue(hint);}}catch(error){console.error(\"Error loading purchased hints:\",error);}},[jackpotContract,accounts,getHintContent]);// eslint-disable-next-line react-hooks/exhaustive-deps\nconst loadContractData=useCallback(async(web3,jackpot,token,bondingCurve,account)=>{try{setIsLoading(true);setStatusMessage('Loading contract data...');// Use Promise.all for concurrent calls\nconst[tokenBalance,tokenSupply,jackpotValue,nextJackpotValue,guessCost,hintCost,totalWinners,uniquePlayers]=await Promise.all([token.methods.balanceOf(account).call(),token.methods.totalSupply().call(),jackpot.methods.jackpotAmount().call(),jackpot.methods.nextJackpotAmount().call(),jackpot.methods.guessCost().call(),jackpot.methods.hintCost().call(),jackpot.methods.totalWinners().call(),jackpot.methods.uniquePlayers().call()]);// Simplified state updates with less formatting\nsetTokenBalance(tokenBalance);setTotalSupply(tokenSupply);// Simplified jackpot value handling\nsetJackpotValue(web3.utils.fromWei(jackpotValue,'ether'));setNextJackpotValue(web3.utils.fromWei(nextJackpotValue,'ether'));// Direct conversion of token amounts\nsetGuessCost((window.BigInt(guessCost)/window.BigInt(10**6)).toString());setHintCost((window.BigInt(hintCost)/window.BigInt(10**6)).toString());setTotalWinners(totalWinners);setUniquePlayers(uniquePlayers);// Optional: Simplified bonding curve data (if needed)\ntry{const poolInfo=await bondingCurve.methods.getPoolInfo().call();setLiquidityValue(web3.utils.fromWei(poolInfo.actualS,'ether'));const currentPriceWei=await bondingCurve.methods.getCurrentPrice().call();setTokenPrice(web3.utils.fromWei(currentPriceWei,'ether'));}catch(err){console.warn(\"Bonding curve data fetch failed:\",err);}setStatusMessage('');}catch(error){console.error(\"Contract data loading error:\",error);setStatusMessage('Error loading data. Check connection.');}finally{setIsLoading(false);}},[]);const buyTokens=async()=>{if(!bondingCurveContract||!web3||!accounts[0]||!numTokens){setStatusMessage('Please connect wallet and enter token amount');return;}// Convert input to base units (directly use the input)\nconst numTokensBaseUnits=Math.floor(parseFloat(numTokens));try{setIsLoading(true);setStatusMessage('Calculating token price...');// Calculate buy price from the contract\nconst costWei=await bondingCurveContract.methods.calculateBuyPrice(numTokensBaseUnits).call();// Log for debugging\nconsole.log('Num Tokens (Base Units):',numTokensBaseUnits);console.log('Cost (Wei):',costWei);console.log('Cost (Ether):',web3.utils.fromWei(costWei,'ether'));setStatusMessage(`Buying tokens... Please confirm in MetaMask (${web3.utils.fromWei(costWei,'ether')} S)`);await bondingCurveContract.methods.buy(numTokensBaseUnits).send({from:accounts[0],value:costWei});setStatusMessage('Tokens purchased successfully!');// Reload contract data\nawait loadContractData(web3,jackpotContract,tokenContract,bondingCurveContract,accounts[0]);setIsLoading(false);}catch(error){console.error(\"Error buying tokens:\",error);setStatusMessage('Error buying tokens. Please try again.');setIsLoading(false);}};const sellTokens=async()=>{if(!bondingCurveContract||!web3||!accounts[0]||!numTokens){setStatusMessage('Please connect wallet and enter token amount');return;}// Convert input to base units (directly use the input)\nconst numTokensBaseUnits=Math.floor(parseFloat(numTokens));try{setIsLoading(true);setStatusMessage('Preparing to sell tokens...');// Check if token is approved\nconst allowance=await tokenContract.methods.allowance(accounts[0],BONDING_CURVE_ADDRESS).call();// Calculate sell price\nconst sellPriceWei=await bondingCurveContract.methods.calculateSellPrice(numTokensBaseUnits).call();console.log('Num Tokens (Base Units):',numTokensBaseUnits);console.log('Sell Price (Wei):',sellPriceWei);console.log('Sell Price (Ether):',web3.utils.fromWei(sellPriceWei,'ether'));// Check if token is approved for the correct amount\nif(parseInt(allowance)<parseInt(web3.utils.toWei(numTokens,'ether'))){// Approve tokens\nsetStatusMessage('Approving tokens for sale... Please confirm in MetaMask');await tokenContract.methods.approve(BONDING_CURVE_ADDRESS,web3.utils.toWei(numTokens,'ether')).send({from:accounts[0]});}setStatusMessage(`Selling tokens... Please confirm in MetaMask (${web3.utils.fromWei(sellPriceWei,'ether')} S)`);await bondingCurveContract.methods.sell(numTokensBaseUnits).send({from:accounts[0]});setStatusMessage('Tokens sold successfully!');// Reload contract data\nawait loadContractData(web3,jackpotContract,tokenContract,bondingCurveContract,accounts[0]);setIsLoading(false);}catch(error){console.error(\"Error selling tokens:\",error);setStatusMessage('Error selling tokens. Please try again.');setIsLoading(false);}};const getHint=async()=>{if(!jackpotContract||!web3||!accounts[0]){setStatusMessage('Please connect wallet first');return;}try{setIsLoading(true);setStatusMessage('Preparing to get hint...');// Check if token is approved\nconst allowance=await tokenContract.methods.allowance(accounts[0],JACKPOT_ADDRESS).call();const hintCostWei=await jackpotContract.methods.hintCost().call();if(parseInt(allowance)<parseInt(hintCostWei)){setStatusMessage('Approving tokens for hint... Please confirm in MetaMask');await tokenContract.methods.approve(JACKPOT_ADDRESS,hintCostWei).send({from:accounts[0]});}setStatusMessage('Purchasing hint... Please confirm in MetaMask');// Request hint - this records the purchase on-chain\nawait jackpotContract.methods.requestHint().send({from:accounts[0]});// Get the latest hint index\nconst hintIndex=parseInt(await jackpotContract.methods.hintCount().call())-1;// Verify purchase was recorded\nconst hasAccess=await jackpotContract.methods.hasAccessToHint(accounts[0],hintIndex).call();if(hasAccess){// Fetch hint from API\nconst hint=await getHintContent(hintIndex,accounts[0]);setHintValue(hint);// Cache in localStorage for offline access\nif(hint&&!hint.startsWith(\"Error\")&&!hint.startsWith(\"Unable\")){localStorage.setItem(`hint_${accounts[0]}_${hintIndex}`,hint);}// Update purchased hints\nsetPurchasedHints(prev=>[...prev,hintIndex]);setStatusMessage('Hint purchased successfully!');}else{setStatusMessage('Error verifying hint purchase. Please try again.');}// Reload token balance\nconst tokenBalanceWei=await tokenContract.methods.balanceOf(accounts[0]).call();setTokenBalance(tokenBalanceWei);setIsLoading(false);}catch(error){console.error(\"Error getting hint:\",error);setStatusMessage('Error getting hint. Please try again.');setIsLoading(false);}};// eslint-disable-next-line react-hooks/exhaustive-deps\nconst calculateGuessChance=useCallback(async()=>{if(!jackpotContract||!web3||!accounts[0]||!currentGuess)return;try{const chance=await jackpotContract.methods.calculateGuessChance(currentGuess).call();setGuessChance(chance/100+'%');}catch(error){console.error(\"Error calculating guess chance:\",error);setGuessChance('0%');}},[jackpotContract,web3,accounts,currentGuess]);const makeGuess=async()=>{if(!jackpotContract||!web3||!accounts[0]||!currentGuess){setStatusMessage('Please connect your wallet and enter a guess');return;}try{setIsLoading(true);setStatusMessage('Submitting guess... Please confirm in your wallet');// Log detailed information about the guess\nconsole.log('Guess Details:',{account:accounts[0],guess:currentGuess,guessLength:currentGuess.length,contractAddress:JACKPOT_ADDRESS});// Additional pre-transaction checks\nconst tokenBalance=await tokenContract.methods.balanceOf(accounts[0]).call();const guessCostWei=await jackpotContract.methods.guessCost().call();console.log('Pre-Guess Checks:',{tokenBalance:tokenBalance.toString(),guessCost:guessCostWei.toString(),hasEnoughBalance:window.BigInt(tokenBalance)>=window.BigInt(guessCostWei)});// Try to get additional contract state information\ntry{const contractState=await Promise.all([jackpotContract.methods.secretHash().call(),jackpotContract.methods.salt().call()]);console.log('Contract Secret State:',{secretHash:contractState[0],salt:contractState[1]});}catch(stateError){console.error('Error fetching contract state:',stateError);}// Attempt the guess\ntry{const result=await jackpotContract.methods.singleStepGuess(currentGuess).send({from:accounts[0]});console.log('Guess Transaction Result:',result);}catch(transactionError){console.error('Comprehensive Transaction Error:',{message:transactionError.message,code:transactionError.code,fullError:transactionError});// More detailed error analysis\nif(transactionError.receipt){console.error('Transaction Receipt:',transactionError.receipt);}// Parse and display a more user-friendly error message\nconst errorMessage=transactionError.message.includes('insufficient')?'Insufficient tokens to make a guess':'Failed to submit guess. Please try again.';setStatusMessage(errorMessage);}setIsLoading(false);}catch(error){console.error(\"Final catch block error:\",error);setStatusMessage('Unexpected error. Please try again.');setIsLoading(false);}};// Updated renderHintHistory function\nconst renderHintHistory=()=>{if(purchasedHints.length===0)return null;return/*#__PURE__*/_jsxs(\"div\",{className:\"hint-history\",children:[/*#__PURE__*/_jsx(\"h3\",{children:\"Your Purchased Hints\"}),/*#__PURE__*/_jsx(\"ul\",{children:purchasedHints.map(index=>{const hintKey=`hint_${accounts[0]}_${index}`;const hintContent=localStorage.getItem(hintKey)||\"Loading hint...\";return/*#__PURE__*/_jsxs(\"li\",{className:\"hint-item\",children:[/*#__PURE__*/_jsxs(\"span\",{className:\"hint-number\",children:[\"Hint #\",index+1,\":\"]}),\" \",hintContent]},index);})})]});};useEffect(()=>{const initWeb3=async()=>{if(window.ethereum){try{setStatusMessage('Connecting to blockchain...');// Request account access with timeout\nconst accounts=await Promise.race([window.ethereum.request({method:'eth_requestAccounts'}),new Promise((_,reject)=>setTimeout(()=>reject(new Error('Connection timeout')),10000))]);if(accounts.length===0){setStatusMessage('Please connect your wallet');return;}const web3Instance=new Web3(window.ethereum);// Initialize contracts with minimal information first\nconst jackpotInstance=new web3Instance.eth.Contract(JackpotGameABI.abi,JACKPOT_ADDRESS);const tokenInstance=new web3Instance.eth.Contract(Token100xABI.abi,TOKEN_ADDRESS);const bondingCurveInstance=new web3Instance.eth.Contract(BondingCurveABI.abi,BONDING_CURVE_ADDRESS);// Set initial state\nsetWeb3(web3Instance);setAccounts(accounts);setJackpotContract(jackpotInstance);setTokenContract(tokenInstance);setBondingCurveContract(bondingCurveInstance);// Load contract data\nawait loadContractData(web3Instance,jackpotInstance,tokenInstance,bondingCurveInstance,accounts[0]);}catch(error){console.error(\"Web3 initialization error:\",error);setStatusMessage(`Connection failed: ${error.message}`);}}else{setStatusMessage('Please install a Web3 wallet like MetaMask');}};initWeb3();},[JACKPOT_ADDRESS,TOKEN_ADDRESS,BONDING_CURVE_ADDRESS,loadContractData]);useEffect(()=>{if(currentGuess&&jackpotContract&&web3&&accounts[0]){calculateGuessChance();}},[currentGuess,jackpotContract,web3,accounts,calculateGuessChance]);useEffect(()=>{if(jackpotContract&&accounts.length>0){loadPurchasedHints();}},[jackpotContract,accounts,loadPurchasedHints]);return/*#__PURE__*/_jsxs(\"div\",{className:\"app-container\",children:[/*#__PURE__*/_jsxs(\"header\",{className:\"app-header\",children:[/*#__PURE__*/_jsx(\"h1\",{className:\"title\",children:\"100X Jackpot Game\"}),/*#__PURE__*/_jsxs(\"p\",{className:\"connected-wallet\",children:[\"Connected: \",accounts.length>0?formatAddress(accounts[0]):'Not connected']}),statusMessage&&/*#__PURE__*/_jsx(\"p\",{className:\"status-message\",children:statusMessage})]}),/*#__PURE__*/_jsxs(\"main\",{className:\"app-main\",children:[/*#__PURE__*/_jsxs(\"section\",{className:\"game-section\",children:[/*#__PURE__*/_jsx(\"h2\",{className:\"section-title\",children:\"Jackpot Game\"}),/*#__PURE__*/_jsxs(\"div\",{className:\"jackpot-info\",children:[/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Current Jackpot: \",jackpotValue,\" S\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Next Jackpot: \",nextJackpotValue,\" S\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Guess Cost: \",guessCost,\" 100X\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Hint Cost: \",hintCost,\" 100X\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Unique Players: \",uniquePlayers]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Total Winners: \",totalWinners]})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"game-controls\",children:[/*#__PURE__*/_jsx(\"input\",{type:\"text\",className:\"guess-input\",placeholder:\"Enter your guess\",value:currentGuess,onChange:e=>setCurrentGuess(e.target.value)}),/*#__PURE__*/_jsxs(\"p\",{className:\"guess-chance\",children:[\"Guess Chance: \",guessChance]}),/*#__PURE__*/_jsx(\"button\",{className:\"action-button make-guess-button\",onClick:makeGuess,disabled:isLoading,children:\"Make Guess\"})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"hint-section\",children:[/*#__PURE__*/_jsx(\"button\",{className:\"action-button hint-button\",onClick:getHint,disabled:isLoading,children:\"Buy Hint\"}),hintValue&&/*#__PURE__*/_jsxs(\"p\",{className:\"hint-value\",children:[\"Hint: \",hintValue]}),renderHintHistory()]})]}),/*#__PURE__*/_jsxs(\"section\",{className:\"token-section\",children:[/*#__PURE__*/_jsx(\"h2\",{className:\"section-title\",children:\"100X Token\"}),/*#__PURE__*/_jsxs(\"div\",{className:\"token-info\",children:[/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Your Balance: \",formatTokenAmount(tokenBalance),\" 100X\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Total Supply: \",formatTokenAmount(totalSupply),\" 100X\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Current Price: \",tokenPrice,\" S\"]}),/*#__PURE__*/_jsxs(\"p\",{className:\"info-item\",children:[\"Liquidity Pool: \",liquidityValue,\" S\"]})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"token-controls\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"mode-toggle\",children:[/*#__PURE__*/_jsx(\"button\",{className:`toggle-button ${buySellMode==='buy'?'active':''}`,onClick:()=>setBuySellMode('buy'),children:\"Buy\"}),/*#__PURE__*/_jsx(\"button\",{className:`toggle-button ${buySellMode==='sell'?'active':''}`,onClick:()=>setBuySellMode('sell'),children:\"Sell\"})]}),/*#__PURE__*/_jsx(\"input\",{type:\"number\",className:\"token-amount-input\",min:\"0\",step:\"1\",placeholder:\"Amount of tokens\",value:numTokens,onChange:e=>setNumTokens(e.target.value)}),buySellMode==='buy'?/*#__PURE__*/_jsx(\"button\",{className:\"action-button buy-button\",onClick:buyTokens,disabled:isLoading,children:\"Buy Tokens\"}):/*#__PURE__*/_jsx(\"button\",{className:\"action-button sell-button\",onClick:sellTokens,disabled:isLoading,children:\"Sell Tokens\"})]})]})]}),/*#__PURE__*/_jsx(\"footer\",{className:\"app-footer\",children:/*#__PURE__*/_jsx(\"p\",{children:\"DeFAI Hackathon Project - Sonic Chain - 2024\"})})]});};export default App;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}